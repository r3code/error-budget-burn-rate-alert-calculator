<!doctype html>
<head>
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <title>Калькулятор времени оповещения о расходе бюджета ошибок SLO</title>
  <style>
    :root {
      font-family: 'Inter', sans-serif;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    body {
      --border: #cdcdcd;
      --border-secondary: #cdcdcd;
      margin: 0;
      line-height: 1.5;
    }

    h1, h2 {
      margin: 1.5rem 0 0 0;
    }

    li {
      margin: 0.4rem 0;
    }

    code {
      font-size: 1rem;
    }

    .airlock {
      width: 80%;
      margin: 5rem auto 2rem auto;
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
    }

    .description {
      width: 80%;
      margin: 0 auto;
    }

    .params {
      width: 30%;
      margin-right: 2rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: inline-block;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .form-group input {
      box-sizing: border-box;
      display: block;
      width: 100%;
      padding: 0.375rem 0.75rem;
      font-size: 1rem;
      line-height: 1.5;
      border: 1px solid var(--border);
      border-radius: 0.25rem;
    }

    .form-group small {
      display: inline-block;
      color: #888;
      font-size: 0.8rem;
      line-height: 1.1rem;
      margin-top: 0.25rem;
    }

    .results {
      border: 1px solid var(--border);
      border-collapse: separate;
      border-radius: 0.25rem;
      border-spacing: 0;
      margin: 1rem 0;
    }

    .results td, .results th {
      padding: 0.25rem;
      border-width: 1px;
      width: 10rem;
      border-bottom: 1px solid var(--border-secondary);
      border-left: 1px solid var(--border-secondary);
      border-right: 0 solid var(--border-secondary);
      border-top: 0 solid var(--border-secondary);
    }

    .results tr th:first-child, .results tr td:first-child {
      width: 5rem;
      min-width: 5rem;
      max-width: 5rem;
    }

    .results th small {
      display: inline-block;
      font-weight: normal;
      color: #666;
    }

    .results td.no-alert {
      color: #aaa;
    }

    .break {
      flex-basis: 100%;
      height: 0;
    }

    @media (max-width: 900px) {
      .airlock {
        width: 100%;
        margin: 5rem 0 2rem 0;
        flex-direction: column;
      }

      .params {
        width: auto;
        margin: 0 2rem;
      }

      .description {
        width: auto;
        margin: 0;
      }

      h1, h2, p, ul, .results {
        margin: 2rem;
      }
    }

  </style>
</head>
<body>
  <div class="airlock">
    Сменить язык: <a href="index.html">English</a>
  </div>
  <div class="airlock">
    <form name="params" class="params" action="javascript:void(0);">
      <div class="form-group">
        <label for="slo">SLO</label>
        <input name="slo" type="text" value="99.9%">
        <small>Процент "хороших" событий?</small>
      </div>
      <div class="form-group">
        <label for="slo-interval">Окно SLO</label>
        <input name="slo-interval" type="text" value="30d">
        <small>В течение какого интервала будет отслеживаться SLO?</small>
      </div>
      <div class="form-group">
        <label for="exhaustion-interval">Время до оповещения о полном исчерпании бюджета ошибок</label>
        <input name="exhaustion-interval" type="text" value="1d">
        <small>За какое время до исчерпания бюджета вас следует предупредить?</small>
      </div>
      <div class="form-group">
        <label for="error-interval">Как долго были ошибки</label>
        <input name="error-interval" type="text" value="">
        <small>Как долго наблюдаются ошибки? (оставьте пустым, если "не прекращаются")</small>
      </div>
    </form>

    <table class="results">
      <tr>
        <th scope="col">частота ошибок</th>
        <th scope="col">время до оповещения</th>
        <th scope="col">
          израсходованно бюджета
          <small>(на момент оповещения, или, если оно не потребовалось, после <span class="slo-interval">Окна SLO</span>)</small>
        </th>
      </tr>
      <tr>
        <th scope="row">0.01%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">0.05%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">0.10%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">0.50%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">1.00%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">5.00%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">10.00%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">50.00%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">90.00%</th>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th scope="row">100.00%</th>
        <td></td>
        <td></td>
      </tr>
    </table>
  </div>

  <div class="description">
    <h1>
      Калькулятор времени оповещения о расходе бюджета ошибок SLO</h1>
    <h2>Что это?</h2>
    <p>
      Это небольшой симулятор, который поможет вам сформировать интуицию об оповещении 
      о скорости расхода бюджета ошибок SLO. Вы можете узнать больше о теории, 
      лежащей в основе оповещения о скорости расхода бюджета ошибок в
      <a href="https://sre.google/workbook/alerting-on-slos/#4-alert-on-burn-rate">SLO Workbook раздел Burn Rate</a>.
    </p>
    <h2>Как этим пользоваться?</h2>
    <p>
      Измените значения в форме и посмотрите, как изменяется "время до оповещения" при разной доле ошибок в таблице. 
      Например, если вы установите SLO на 99.95% интервал 14d и настроите "Время до оповещения о полном 
      исчерпании бюджета ошибок" 6h, вы увидите, что:
    </p>
    <ul>
      <li>
        Вы будете уведомлены о полном исчерпании примерно через 2м 32с.</li>
      <li>
        Вы будете предупреждены при доле ошибок 10% чуть более чем через 25m.</li>
      <li>
         Доля ошибок 1% исчерпает ваш бюджет, и примерно через 11 часов вы 
        будете уже менее чем в 6 часах от исчерпания своего бюджета, и вы будете оповещены.
      </li>
      <li>
        Доля ошибок 0.01% значительно ниже доли ошибок вашего SLO 0.05%, поэтому вы никогда не получите оповещения.
      </li>
    </ul>
    <h2>
      Почему к моменту срабатывания оповещения я израсходовал 25% своего бюджета?</h2>
    <p>
      Этот калькулятор пытается эмулировать способ, которым Honeycomb реализует оповещения о сгорании. 
      Вы можете прочитать больше о <a href="https://docs.honeycomb.io/working-with-your-data/slos/slo-process/#define-burn-alerts">Honeycomb Burn Alerts в их документах</a>.
    </p>
    <p>
      В Honeycomb вы не настраиваете скорость сгорания и интервал обратного просмотра независимо. 
      Вы указываете интервал исчерпания бюджета ошибок, который определяет чувствительность оповещения, 
      и ¼ этого интервала исчерпания используется как интервал обратного просмотра для оповещения.
    </p>
    <p>
      Это означает, что для высоких показателей расхода (когда вы в противном случае израсходовали бы 
      весь свой бюджет в течение окна оповещения об исчерпании) оповещение сработает, как только вы 
      израсходуете 25% своего бюджета ошибок. Более низкие показатели сжигания сработают позже, 
      после сжигания большей части вашего бюджета.
    </p>
    <h2>Может ли он показать мне, сколько времени потребуется, чтобы полностью израсходовать мой бюджет ошибок??</h2>
    <p>
      Да! Укажите <code>0</code> (ноль) как Время до оповещения о полном исчерпании бюджета ошибок.
    </p>
    <h2>
      Это совершенно нереально!</h2>
    <p>
      Это абсолютно так. Он делает несколько упрощающих предположений, которые вряд ли будут верны в реальной жизни. 
      Предполагается, что частота событий SLI постоянна, и предполагается, что любые возникающие ошибки постоянны. 
      По иронии судьбы, именно когда эти предположения нарушаются, оповещения о скорости расхода могут быть наиболее полезными.
    </p>
    <p>
      Если вы хотите помочь расширить калькулятор для моделирования более интересных сценариев, 
      таких как изменение частоты ошибок, пожалуйста, <a
     href="https://github.com/nickstenning/burnrate">присоединяйтесь на GitHub!</a>
    </p>
    <h2>Автор</h2>
    <p>
      <a href="https://twitter.com/nickstenning">Nick Stenning</a>. Пишите в X.
    </p>
    <p>
      Переведно <a href="https://github.com/r3code/">r3code</a>
    </p>
  </div>

  <script>
    // What proportion of the exhaustion interval is used for alert lookback?
    const LOOKBACK_FRACTION = 0.25;

    const DURATIONS = new Map();
    DURATIONS.set("d", 86400);
    DURATIONS.set("h", 3600);
    DURATIONS.set("m", 60);
    DURATIONS.set("s", 1);

    function calculate() {
      console.log('calculate called');
      const params = document.querySelector("form[name=params]");
      const results = document.querySelector("table.results");
      const slo = document.querySelector("table span.slo-interval");
      const p = validate(params);
      if (!p) {
        return;
      }

      slo.textContent = renderDuration(p.sloInterval);

      const errorRates = [...results.querySelectorAll("tr:not(:first-of-type) th")].map(e => parsePercentage(e.textContent));

      errorRates.forEach((errorRate, errorRateIdx) => {
        const result = timeToAlert(errorRate, p.slo, p.sloInterval, p.exhaustionInterval);

        const cell = results.querySelector(`tr:nth-child(${2 + errorRateIdx}) td:nth-of-type(1)`);
        const budgetCell = results.querySelector(`tr:nth-child(${2 + errorRateIdx}) td:nth-of-type(2)`);

        const doesAlert = !isNaN(result.alertsAfter) && (isNaN(p.errorInterval) || result.alertsAfter < p.errorInterval);

        if (doesAlert) {
          cell.textContent = renderDuration(result.alertsAfter);
          cell.classList.add('alert');
          cell.classList.remove('no-alert');
          budgetCell.textContent = renderPercentage(result.budgetBurned);
        } else {
          cell.textContent = renderDuration(NaN);
          cell.classList.add('no-alert');
          cell.classList.remove('alert');
          const errorInterval = isNaN(p.errorInterval) ? p.sloInterval : p.errorInterval;
          const budgetInterval = isNaN(result.alertsAfter) ? p.sloInterval : result.alertsAfter;
          const factor = errorInterval / budgetInterval;
          budgetCell.textContent = renderPercentage(result.budgetBurned * factor);
        }
      });
    }

    function timeToAlert(errorRate, slo, sloInterval, exhaustionInterval) {
      const lookbackFactor = 0.25;
      const sloErrorRate = 1 - slo;

      let result = {
        alertsAfter: NaN,
        budgetBurned: 0,
      };

      if (errorRate < sloErrorRate) {
        result.budgetBurned = errorRate/sloErrorRate;
        return result;
      }

      const timeToExhaustion = sloInterval * sloErrorRate / errorRate;

      if ((1 - lookbackFactor) * timeToExhaustion > exhaustionInterval + 1e-6) {
        result.alertsAfter = timeToExhaustion - exhaustionInterval;
        result.budgetBurned = 1 - exhaustionInterval / timeToExhaustion;
      } else {
        result.alertsAfter = lookbackFactor * timeToExhaustion;
        result.budgetBurned = lookbackFactor;
      }
      return result;
    }

    function validate(form) {
      const slo = parseFloat(form['slo'].value) / 100;
      const sloInterval = parseDuration(form['slo-interval'].value);
      const exhaustionInterval = parseDuration(form['exhaustion-interval'].value);
      let errorInterval = parseDuration(form['error-interval'].value);

      if (isNaN(slo) || isNaN(sloInterval) || isNaN(exhaustionInterval)) {
        return false;
      }

      if (slo <= 0 || slo > 100) {
        return false;
      }

      if (sloInterval <= 0) {
        return false;
      }

      if (exhaustionInterval < 0) {
        return false;
      }

      if (errorInterval < 0) {
        return false;
      }

      // Maximum allowable error interval is the SLO interval
      if (errorInterval > sloInterval) {
        errorInterval = sloInterval;
      }

      return { slo, sloInterval, exhaustionInterval, errorInterval };
    }

    function parsePercentage(str) {
      const val = str.slice(0, -1);
      return parseFloat(val) / 100;
    }

    function parseDuration(str) {
      const count = str.slice(0, -1);
      const unit = str.slice(-1);
      if (!DURATIONS.has(unit)) {
        return parseInt(str);
      }
      return parseInt(count) * DURATIONS.get(unit);
    }

    function renderDuration(seconds) {
      seconds = Math.ceil(seconds);
      if (isNaN(seconds)) {
        return "никогда";
      }
      const out = [];
      for (const [c, n] of DURATIONS) {
        let i = 0;
        while (seconds >= n) {
          i += 1;
          seconds -= n;
        }
        if (i > 0) {
          out.push(`${i}${c}`);
        }
      }
      return out.join(' ');
    }

    function renderPercentage(value) {
      return (value * 100).toFixed(2) + '%';
    }

    document.addEventListener("DOMContentLoaded", calculate);
    document.querySelectorAll("input").forEach(el => el.addEventListener("input", calculate));
  </script>
</body>
